/*
    숫자형
        - 자바스크립트는 숫자형을 2가지의 자료형이 있다.
            1. 일반적인 숫자는 '배정밀도 부동소수점 숫자(double precision floating point number)'로 알려진 64비트 형식의 IEEE-754에 저장
            2. bigInt는   2의53승 이상이거나 -2의53승이하일 수 없다는 제약 때문에 BigInt라는 새로운 자료형
*/

/*
    숫자를 입력하는 다양한 방법
    let billion = 1000000000;

    10억을 적을 때 0이 많아 헷갈리고 입력하기 귀찮다 그래서 10억은 '1bn' 73억은 '7.3bn'을 사용함 큰 숫자를 나타낼 땐 이러한 방식을 주로 사용
    
    자바스크립트에서는 숫자 옆에 'e'를 붙이고 0의 개수를 그 옆에 붙여주면 숫자를 줄일 수 있다.

    let billion = 1e9; //10억 1과 9개의 0
    alert(7.3e9) 73억 (7,300,000,000)

    즉 'e'는 'e' 왼쪽의 수에 'e' 오른쪽에 있는 수만큼 10의 거듭제곱을 하는 효과가 있다

    이제 아주 작은 숫자인 1마이크로초(백만 분의 1초)를 표현하는 방법
    let ms = 0.000001;
    작은 숫자를 표현할 때도 큰 숫자를 표현한 것처럼 'e'를 사용할 수 있다
    let ms = 1e-6 //1에서 왼쪽으로 6번 소수점 이동
    0.000001에서 0의 갯수를 세면 6이므로 0.000001은 당연히 1e-6이 된다.
    이렇게 'e'우측에 음수가 있으면, 이 음수의 절댓값 만큼 10을 거듭제곱한 수로 나누는 것을 의미

    //10을 세번 거듭제곱한 수로 나눔
    1e-3 = 1/1000 (=0.001)
    //10을 여섯번 거듭제곱한 수로 나눔
    1.23e-6 = 1.23 / 1000000 (= 0.00000123)

    16진수, 2진수, 8진수
    16진수는 색, 문자를 인코딩할 때 주로 쓰임 16진수는 0x를 사용해 표현할 수 있다

    console.log(0xff); //255
    console.log(0xFF); //255 (대소문자를 가리지 않음으로 어떤 것을 써도 상관 없다)

    2진수와 8진수는 아주 드물게 쓰이긴 하지만, 접두사 0b와 0o를 사용하여 간단하게 나타낼 수 있다.
    let a = 0b11111111; // 255의 2진수
    let b = 0o377; // 255의 8진수

    자바스크립트에서 지원하는 진법은 3개 입니다. 이외의 진법을 사용하려면 함수 parseInt를 사용해야 한다.
*/

/*
    toString(base) 진법계산
        - num.toString(base)메서드는 base진법으로 num을 표현한 후, 이를 문자형으로 변환해 반환합니다.
        let num = 255;
        console.log(num.toString(16)) //16진법
        console.log(num.toString(8)) //8진법
        console.log(num.toString(2)) //2진법
        //base36 : 사용할 수 있는 base 값 최댓값으로 0..9와 A..Z를 사용해 숫자를 표현 36베이스는 url을 줄이는 것과 같이 숫자로 된 긴 식별자를 줄일 때 유용하다.
        console.log(123456..toString(36))
        // 점 두개와 메서드 호출
        // 숫자를 대상으로 메서드 toString()을 호출하고 싶다면 ..을 2개 붙혀야 한다.
        // 점 한개만 사용하면 첫 번째 점 이후는 소수부로 인식되어 에러가 발생할 수 있다.
*/

/*
    어림수 구하기 : 숫자를 다룰 때 가장 많이 사용되는 연산 중 하나입니다.
    Math.floor : 소수점 첫째 자리에서 내림(버림) 3.1 = 3, -1.1 = -2
    Math.ceil : 소수점 첫째 자리에서 올림 3.1 = 4, -1.1 = -1
    Math.round : 소수점 첫째 자리에서 올림 3.1 = 4, -1.1 = -1
    Math.trunc(익스지원x) : 소수점을 무시 3.1 = 3, -1.1 = -1

    만약 소수점을 3번째자리 까지 구하고 싶다면 (곱하기와 나누기)
    let num = 1.23456;
    console.log(Math.floor(num * 100) / 100) // 1.23456 - > 123.456 -> 1.23

    소수점 n번째 수까지 어림수를 구한디 이를 문자형으로 변환해주는 메서드인 toFixed(n)을 사용
    let num = 12.34;
    console.log(num.toFixed(1)) //toFixed는 Math.round와 유사하게 가장 가까운 값으로 올림 혹은 버림을 실행
    toFixed를 사용할 때 주의할 점은 이메서드는 반환 값이 문자열이다. 소수부의 길이가 인수보다 작으면 뒤에 0을 추가 한다.
    let num = 12.34
    console.log(num.toFixed(3)) //3은 소수점 자리 -> 뒤에 소수점이 없으면 뒤에 0을 추가
    문자열을 숫자형으로 변환하고 싶으면 Number(), +를 사용하면 됌
*/

/*
    부정확한 계산 : 숫자는 내부적으로 64비트 형식 IEEE-754으로 표현되기 때문에 숫자를 저장하려면 정확히 64비트가 필요하다. 
                   64비트 중 52비트는 숫자를 저장하는 데 사용되고, 11비트는 소수점 위치를(정수는 0), 1비트는 부호를 저장하는 데 사용됩니다.
                   
        - 숫자가 너무 커지면 64비트 공간이 넘쳐서 Infinity로 처리 됨(console.log(1e500)) // Infinity
        - 정밀도 손실
            1. console.log(0.1 + 0.2  == 0.3) //false
                - 0.1 + 0.2 = 0.30000000000000004

            숫자는 0과 1로 이루어진 이진수로 변환되어 연속된 메모리 공간에 저장됩니다. 
            그런데 10진법을 사용하면 쉽게 표현할 수 있는 0.1, 0.2 같은 분수는 이진법으로 표현하면 무한 소수가 됩니다.
            0.1은 1을 10으로 나눈 수인 1/10입니다. 10진법을 사용하면 이러한 숫자를 쉽게 표현할 수 있죠. 1/10과 1/3을 비교해봅시다. 
            1/3은 무한 소수 0.33333(3)이 됩니다.
            이렇게 10의 거듭제곱으로 나눈 값은 10진법에서 잘 동작하지만 3으로 나누게 되면 10진법에서 제대로 동작하지 않습니다. 
            같은 이유로 2진법 체계에서 2의 거듭제곱으로 나눈 값은 잘 동작하지만 1/10같이 2의 거듭제곱이 아닌 값으로 나누게 되면 무한 소수가 되어버립니다.
            10진법에서 1/3을 정확히 나타낼 수 없듯이, 2진법을 사용해 0.1 또는 0.2를 정확하게 저장하는 방법은 없습니다.

        - 해결 방법
            1. toFixed를 사용
                let sum = 0.1 + 0.2;
                console.log(sum.toFixed(2)) // 0.30
            2. 숫자에 임시로 100(또는 더 큰 숫자)을 곱하여 정수로 바꾸고, 원하는 연산을 한 후 다시 100으로 나누는 것도 하나의 방법이 될 수 있습니다.
                console.log( (0.1 * 10 + 0.2 * 10) / 10 ); // 0.3
                console.log( (0.28 * 100 + 0.14 * 100) / 100); // 0.4200000000000001
        
        이렇게 10의 거듭제곱을 곱하고 다시 동일한 숫자로 나누는 전략은 오류를 줄여주긴 하지만 완전히 없애지는 못합니다.
        구현을 하다 보면 무한 소수가 나오는 경우를 완전히 차단해야 하는 경우가 생기곤 합니다. 
        달러가 아닌 센트 단위로 물품 가격을 저장하는 쇼핑몰을 담당하고 있는데, 행사 때문에 가격을 30% 할인해야 하는 경우가 그렇죠. 
        무한소수를 방지하는 완벽한 방법은 사실 없습니다. 필요할 때마다 '꼬리’를 잘라 어림수를 만드는 방법뿐이죠.

        console.log( 9999999999999999 ); // 10000000000000000이 출력됩니다.
            - 숫자를 저장하는 공간이 모자라서 최소유효숫자가 손실됨, 하지만 자바스크립트는 오류를 발생시키지 않음
        두 종류의 0
            - 자바스크립트는 0과 -0이 있음 숫자의 부호가 단일 비트에 저장되는데 0을 포함한 모든 숫자에 부호를 설정할수도 하지 않을 수도 있음
*/  

/*
    isNaN, isFinite
        -Infinity, -Infinity : 큰 혹은 작은 특수 숫자 값
        - NaN : 에러를 나타내는 값
        - 두 특수 숫자는 숫자형에 속하지만 '정상적인' 숫자는 아니기 때문에, 정상적인 숫자와 구분하기 위한 특별한 함수가 존재

        1. isNaN(value) : 인수를 숫자로 변환한 다음 NaN인지 테스트
            - console.log( isNaN(NaN) ); // true
            - console.log( isNaN("str") ); // true
            - 'str' === NaN으로 해도 되냐고 물으신다면! 그건 안돼! 왜냐 NaN은 NaN===NaN : false기 떄문이지 흐흐흐

        2.isFinite : 문자열이 일반 숫자인지 검증하는데 사용
            - console.log(isFinite("15")) // true
            - console.log(isFinite("str")) // false, NaN이기 떄문이다
            - isFinite는 문자열이 일반 숫자인지 검증하는 데 사용되곤 합니다.
            - 빈 문자열이나 공백만 있는 문자열은 isFinite를 포함한 모든 숫자 관련 내장 함수에서 0으로 취급된다는 점에 유의하시기 바랍니다.
*/

/*
    parseInt, parseFloat
        - 단항 덧셈 연산자 (+), Number()를 사용하여 숫자형으로 변형할 때 적용되는 규칙는 꽤 엄격하다 피연산자가 숫자가 아니면 형 변환이 실패 된다.
        - console.log(+"100px") -> // NaN
        - '100px', '12px', '19won'등을 숫자만 추추하는 방법
        - parseInt와 parseFloat는 숫자를 읽는 도중 오류가 발생하면 이미 수집된 숫자만 반환한다.
        - parseInt : 정수
        - parseFloat : 부동 소수점

        console.log(parseInt('1000px')) //1000
        console.log(parseInt('12.5rem')) //12 정수만 반환
        console.log(parseFloat('12.3rem')) // 12.3 소수점까지 반환
        console.log(parseFloat('12.3.4')) //12.3, 두 번째 점에서 숫자 읽기를 멈춘다.

        parseInt(str, radix)의 두번째 인수는 진수를 지정할 때 사용(16진수, 8진수. 2진수)
        console.log(parseInt('1000px',16))
*/

/*
    기타 수학 함수
    console.log(Math.random()); // 0 ~ 1사의 난수를 반환함 0.153153138131 
    console.log(Math.max(3, 5, -10, 0, 1)); // 인수중 최대 값 반환한다.
    console.log(Math.min(3, 5, -10, 0, 1)); // 인수중 최소 값 반환한다.
    console.log(Math.pow(2, 10)); // 2를 10번 제곱한다.
*/

/*
    요약
    0이 많이 붙은 큰 숫자는 다음과 같은 방법을 사용해 씁니다.

    0의 개수를 'e' 뒤에 추가합니다. 123e6은 0이 6개인 숫자, 123000000을 나타냅니다.
    'e' 다음에 음수가 오면, 음수의 절댓값 만큼 10을 거듭제곱한 숫자로 주어진 숫자를 나눕니다. 123e-6은 0.000123을 나타냅니다.
    다양한 진법을 사용할 수도 있습니다.

    자바스크립트는 특별한 변환 없이 16진수(0x), 8진수(0o), 2진수(0b)를 바로 사용할 수 있게 지원합니다.
    parseInt(str, base)를 사용하면 str을 base진수로 바꿔줍니다(단, 2 ≤ base ≤ 36).
    num.toString(base)는 숫자를 base진수로 바꾸고, 이를 문자열 형태로 반환합니다.
    12pt나 100px과 같은 값을 숫자로 변환하는 것도 가능합니다.

    parseInt/parseFloat를 사용하면 문자열에서 숫자만 읽고, 읽은 숫자를 에러가 발생하기 전에 반환해주는 ‘약한’ 형 변환을 사용할 수 있습니다.
    소수를 처리하는 데 쓰이는 메서드는 다음과 같습니다.

    Math.floor, Math.ceil, Math.trunc, Math.round, num.toFixed(precision)를 사용하면 어림수를 구할 수 있습니다.
    소수를 다룰 땐 정밀도 손실에 주의하세요.
    이 외에도 다양한 수학 함수가 있습니다.

    수학 연산이 필요할 때 Math 객체를 찾아보세요. 작은 객체이지만 기본적인 연산은 대부분 다룰 수 있습니다.
    */