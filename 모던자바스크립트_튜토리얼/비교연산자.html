<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>
<body>
    <script>
        //기본적으로 아는 지식이니 빠르게 넘어감.
        /*
        단어 정리
            ==(동등 연산자)
            ===(일치 연산자)
        */
        /*
        블린형 반환 : 다른 연산자와 마찬가지로 비교 연산자 역시 값을 반환, 반환 값은 블린형 (True, false)
        문자열 비교 : '사전 순'으로 문자열 비교. 
            두 문자열의 첫 글자를 비교합니다.
            첫 번째 문자열의 첫 글자가 다른 문자열의 첫 글자보다 크면(작으면), 첫 번째 문자열이 두 번째 문자열보다 크다고(작다고) 결론 내고 비교를 종료합니다.
            두 문자열의 첫 글자가 같으면 두 번째 글자를 같은 방식으로 비교합니다.
            글자 간 비교가 끝날 때까지 이 과정을 반복합니다.
            비교가 종료되었고 문자열의 길이도 같다면 두 문자열은 동일하다고 결론 냅니다. 비교가 종료되었지만 두 문자열의 길이가 다르면 길이가 긴 문자열이 더 크다고 결론 냅니다.

            정확히는 사전순이 아니라 유니코드 순입니다.
            차이점 중 하나는 자바스크립트는 대·소문자를 따진다는 것입니다. 
            대문자 "A"와 소문자 "a"를 비교했을 때 소문자 "a"가 더 큽니다. 자바스크립트 내부에서 사용되는 인코딩 표인 유니코드에선 소문자가 대문자보다 더 큰 인덱스를 갖기 때문이죠. 
        */
        /*
        다른 형을 가진 값 간의 비교
            alert( '2' > 1 ); // true, 문자열 '2'가 숫자 2로 변환된 후 비교가 진행됩니다.
            alert( '01' == 1 ); // true, 문자열 '01'이 숫자 1로 변환된 후 비교가 진행됩니다.let a = 0;
            alert( Boolean(a) ); // false

            let b = "0";
            alert( Boolean(b) ); // true
            alert(a == b); // true!
            동등 비교 연산자 ==는 (예시에서 문자열 "0"을 숫자 0으로 변환시킨 것처럼) 피연산자를 숫자형으로 바꾸지만, 
            'Boolean’을 사용한 명시적 변환에는 다른 규칙이 사용되기 때문입니다.
            ==는 문자열을 숫자로 바꿈
            boolean은 다른 규칙이 적용 됌
        */
        /*
        일치 연산자
        ==는 false 와 0을 구분 못함(0==false), ('' == false)도 구분 못함
        ==는 피연산자를 0으로 치환하여 발생하는 문제임('', false는 0이기 때문 ) => ==는 피연산자를 형변환을 하여 비교한다는 뜻~

        ===는 형변환 없이 비교함
        (0 === false) = false 자료형까지 검사하기 때문에 비교 가능
        일치 연산자는 동등 연산자보다 한 글자 더 길긴 하지만 비교 결과가 명확하기 때문에 에러가 발생할 확률을 줄여줍니다.
        */

        /*
        null, undefined와 비교
        일치 연산자(===)를 사용하여 null, undefined를 비교하면 false값 리턴 두 값의 자료형이 다르기 때문
        동등 연산자(==)를 사용하여 비교하면 true값 리턴

        alert( null > 0 );  // (1) false
        alert( null == 0 ); // (2) false ==는 펄즈 반환 방식이 다르기 때문에(>,<,>=,<=와 다름)
        alert( null >= 0 ); // (3) true == null은 0과 같아서 true 반환
        null을 비교할 때 null 값을 0으로 되어있음.
        3번의 경우에는 true값이 리턴되는데 그러면 2번도 맞아야 함.
        하지만 == 와 (<,>,<=,>=)의 동작 방식이 다름

        ==(동등연산자)는 피연산자가 undefined, null 일때 형 반환을 하지 않음. undefined, null을 비교할 때만 true를 반환하고 그외의 경우는 false 반환

        undefined는 다른 값과 비교를 하면 안됌.
        alert( undefined > 0 ); // false (1) undefined = NaN으로 변환. NaN이 피연산자와 비교연산을 할 경우 false로 반환
        alert( undefined < 0 ); // false (2)
        alert( undefined == 0 ); // false (3)
        undefined는 null이나 undefined와 같고, 그 이외의 값과는 같지 않기 때문에 (3)은 false를 반환. ( null == undefined );  true
        */

        /*
        일치 연산자 ===를 제외한 비교 연산자의 피연산자에 undefined나 null이 오지 않도록 특별히 주의하시기 바랍니다.
        또한, undefined나 null이 될 가능성이 있는 변수가 >= > < <=의 피연산자가 되지 않도록 주의하시기 바랍니다. 
        명확한 의도를 갖고 있지 않은 이상 말이죠. 만약 변수가 undefined나 null이 될 가능성이 있다고 판단되면, 
        이를 따로 처리하는 코드를 추가하시기 바랍니다.
        */

        /*
        요약 
        비교 연산자는 불린값을 반환합니다.
        문자열은 문자 단위로 비교되는데, 이때 비교 기준은 '사전’순입니다. a보다 z가 더큼~
        서로 다른 타입의 값을 비교할 땐 숫자형으로 형 변환이 이뤄지고 난 후 비교가 진행됩니다(일치 연산자는 제외)("0" == 0 =>true).
        null과 undefined는 동등 비교(==) 시 서로 같지만 다른 값과는 같지 않습니다.
        null이나 undefined가 될 확률이 있는 변수가 > 또는 <의 피연산자로 올 때는 주의를 기울이시기 바랍니다.
        null/undefined 여부를 확인하는 코드를 따로 추가하는 습관을 들이길 권유합니다.
        */


        /*
        5 > 4 true 5는 4보다 크다.
        "apple" > "pineapple" false 사전적으로 p가 더 뒤에 있어서 펄즈
        "2" > "12" true 2번과 같은 맥락
        undefined == null true 두개의 비교는 가능
        undefined === null false 두개는 일치하지 않음
        null == "\n0\n" false null은 오직 undefined에만 일치
        null === +"\n0\n" false 형이 다름
        */
    </script>
</body>
</html>